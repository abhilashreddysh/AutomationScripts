#!/bin/bash

# Configuration variables
USER="your_username"          # The SSH username to use
KEY_DIR="$HOME/.ssh"
PRIVATE_KEY="$KEY_DIR/id_rsa"
PUBLIC_KEY="$KEY_DIR/id_rsa.pub"
LOG_FILE="$HOME/ssh_key_deployment.log"
SERVER_LIST_FILE="servers.txt"  # File containing server names

# Silent Mode Flag (by default, it's off)
SILENT_MODE=false
LOG_LEVEL="INFO"
KEY_TYPE="rsa"  # Default key type (can be changed to ed25519, ecdsa)

# Retry configuration
RETRIES=3
RETRY_DELAY=5

# Email configuration
SEND_EMAIL=false
EMAIL_ADDRESS="your_email@example.com"

# Function to log messages with timestamp and log level
log_message() {
    local level=$1
    local message=$2
    if [[ "$LOG_LEVEL" == "DEBUG" || "$LOG_LEVEL" == "$level" ]]; then
        local log_msg="$(date '+%Y-%m-%d %H:%M:%S') - $level: $message"
        if ! $SILENT_MODE; then
            echo "$log_msg" | tee -a "$LOG_FILE"
        else
            # Only log errors in silent mode
            if [[ "$level" == "ERROR" || "$level" == "WARN" ]]; then
                echo "$log_msg" | tee -a "$LOG_FILE"
            fi
        fi
    fi
}

# Function to send an email notification
send_email_notification() {
    if $SEND_EMAIL; then
        local subject=$1
        local message=$2
        echo "$message" | mail -s "$subject" "$EMAIL_ADDRESS"
    fi
}

# Function to generate a new SSH key pair
generate_ssh_key() {
    log_message "INFO" "Generating a new SSH $KEY_TYPE key pair..."

    # Remove existing keys (optional - this ensures we don't reuse old keys)
    if [[ -f "$PRIVATE_KEY" || -f "$PUBLIC_KEY" ]]; then
        log_message "INFO" "Removing existing SSH keys..."
        rm -f "$PRIVATE_KEY" "$PUBLIC_KEY"
    fi

    # Generate a new SSH key pair based on the selected key type
    ssh-keygen -t "$KEY_TYPE" -b 4096 -f "$PRIVATE_KEY" -N "" -C "Generated by SSH Key Script - $USER"
    if [[ $? -eq 0 ]]; then
        log_message "INFO" "$KEY_TYPE key pair generated successfully."
    else
        log_message "ERROR" "Failed to generate SSH key pair."
        exit 1
    fi
}

# Function to attempt SSH connection with retries
attempt_ssh_connection() {
    local server=$1
    local attempt=1

    while [[ $attempt -le $RETRIES ]]; do
        ssh -o ConnectTimeout=10 "$USER@$server" "echo 'Connection test'" &>/dev/null
        if [[ $? -eq 0 ]]; then
            return 0  # Success
        else
            log_message "WARN" "Attempt $attempt failed to connect to $server. Retrying in $RETRY_DELAY seconds..."
            sleep $RETRY_DELAY
            ((attempt++))
        fi
    done

    log_message "ERROR" "Failed to connect to $server after $RETRIES attempts."
    return 1  # Failure
}

# Function to check if the key already exists on the server
key_exists_on_server() {
    local server=$1
    if ssh "$USER@$server" "grep -q '$(cat $PUBLIC_KEY)' ~/.ssh/authorized_keys"; then
        return 0  # Key exists
    else
        return 1  # Key does not exist
    fi
}

# Function to validate server name or IP address
validate_server_name() {
    local server=$1
    if [[ "$server" =~ ^[a-zA-Z0-9.-]+$ ]] || [[ "$server" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        return 0  # Valid server name or IP address
    else
        return 1  # Invalid server name
    fi
}

# Function to deploy SSH key to a server
deploy_ssh_key_to_server() {
    local server=$1

    # Validate the server name
    if ! validate_server_name "$server"; then
        log_message "ERROR" "Invalid server name or IP address: $server. Skipping."
        return
    fi

    log_message "INFO" "Deploying SSH key to $USER@$server..."

    # Check if the key already exists on the server
    if key_exists_on_server "$server"; then
        log_message "INFO" "SSH key already exists on $USER@$server. Skipping deployment."
    else
        attempt_ssh_connection "$server" || return 1

        # Proceed with deployment if SSH connection was successful
        if command -v ssh-copy-id &> /dev/null; then
            ssh-copy-id -i "$PUBLIC_KEY" "$USER@$server" &>> "$LOG_FILE"
        else
            ssh "$USER@$server" "mkdir -p ~/.ssh && echo '$(cat $PUBLIC_KEY)' >> ~/.ssh/authorized_keys" &>> "$LOG_FILE"
        fi

        if [[ $? -eq 0 ]]; then
            log_message "INFO" "Successfully deployed SSH key to $USER@$server."
        else
            log_message "ERROR" "Failed to deploy SSH key to $USER@$server."
        fi
    fi
}

# Function to process command-line arguments for silent mode
process_arguments() {
    while getopts "s" opt; do
        case $opt in
            s)  # Enable silent mode
                SILENT_MODE=true
                log_message "INFO" "Silent mode enabled. Only errors will be logged."
                ;;
            *)  # Invalid option
                echo "Usage: $0 [-s] (Silent mode)"
                exit 1
                ;;
        esac
    done
}

# Main script execution
process_arguments "$@"  # Parse command-line arguments

log_message "INFO" "Starting SSH key deployment process..."

# Read the server names from the file
if [[ ! -f "$SERVER_LIST_FILE" ]]; then
    log_message "ERROR" "Server list file ($SERVER_LIST_FILE) not found!"
    exit 1
fi

SERVERS=()
while IFS= read -r server; do
    # Ignore empty lines and comments
    if [[ -n "$server" && "$server" != \#* ]]; then
        SERVERS+=("$server")
    fi
done < "$SERVER_LIST_FILE"

if [[ ${#SERVERS[@]} -eq 0 ]]; then
    log_message "ERROR" "No servers found in the server list file."
    exit 1
fi

# Generate new SSH key pair (cycle the keys)
generate_ssh_key

# Deploy SSH key to each server
for SERVER in "${SERVERS[@]}"; do
    deploy_ssh_key_to_server "$SERVER"
done

# Send email notification (if enabled)
send_email_notification "SSH Key Deployment Status" "The SSH key deployment has been completed successfully."

log_message "INFO" "SSH key deployment completed."
